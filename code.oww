settings
{
	main
	{
		Description: "CODE: RHGDH made by paharo"
		Mode Name: "Kephrii's Custom"
	}

	lobby
	{
		Allow Players Who Are In Queue: Yes
		Match Voice Chat: Enabled
	}

	modes
	{
		Assault
		{
			enabled maps
			{
			}
		}

		Control
		{
			enabled maps
			{
			}
		}

		Escort
		{
			enabled maps
			{
			}
		}

		Flashpoint
		{
			disabled maps
			{
				Suravasa
			}
		}

		Hybrid
		{
			enabled maps
			{
			}
		}

		Push
		{
			enabled maps
			{
			}
		}

		General
		{
			Health Pack Respawn Time Scalar: 10%
			Hero Limit: Off
			Respawn Time Scalar: 0%
			Spawn Health Packs: Enabled
		}
	}

	heroes
	{
		General
		{
			Ability Cooldown Time: 0%
			Spawn With Ultimate Ready: On
			Ultimate Generation: 500%
			Ultimate Generation - Combat: 500%
			Ultimate Generation - Passive: 500%

			Ana
			{
				Biotic Grenade Cooldown Time: 0%
				Sleep Dart Cooldown Time: 0%
				Spawn With Ultimate Ready: On
				Ultimate Generation - Combat Nano Boost: 500%
				Ultimate Generation - Passive Nano Boost: 500%
				Ultimate Generation Nano Boost: 500%
			}

			Ashe
			{
				Coach Gun Cooldown Time: 0%
				Dynamite Cooldown Time: 0%
				Spawn With Ultimate Ready: On
				Ultimate Generation - Combat B.O.B.: 500%
				Ultimate Generation - Passive B.O.B.: 500%
				Ultimate Generation B.O.B.: 500%
			}

			Baptiste
			{
				Immortality Field Cooldown Time: 0%
				Regenerative Burst Cooldown Time: 0%
				Spawn With Ultimate Ready: On
				Ultimate Generation - Combat Amplification Matrix: 500%
				Ultimate Generation - Passive Amplification Matrix: 500%
				Ultimate Generation Amplification Matrix: 500%
			}

			Torbjörn
			{
				Deploy Turret Cooldown Time: 0%
			}
		}
	}

	extensions
	{
		Spawn More Dummy Bots
	}
}

variables
{
	global:
		26: CODE
		27: MAP_CURRENT
		28: MAP_ARRAY
		30: CODE_VERSION
		31: AUTO_CHANGE_PLAYERS
		70: data
		71: loop_i
		72: map_deathplane_y
		73: _FX

	player:
		26: CHANGE_HERO_ARRAY
		27: USING_FLY
		28: SPECTATE_ENABLED
		29: SPECTATE_PLAYER
		30: SAVE_POS_CROUCH_CHASE
		31: SAVE_POS_ARRAY
		32: SAVE_POS_RELOAD_CHASE
		33: MACRO_PLAYER_ARRAY
		34: MACRO_DUMMY_SETTINGS
		35: MACRO_CHASE_VAR
		36: MACRO_RECORDING
		37: MACRO_DATA_FACING
		38: MACRO_DATA_POSITION
		39: MACRO_DATA_HOLDING_ULT
		40: MACRO_DATA_HOLDING_AB1
		41: MACRO_DATA_HOLDING_AB2
		42: MACRO_DATA_HOLDING_PRIMARY
		43: MACRO_DATA_HOLDING_SECONDARY
		44: MACRO_DATA_HOLDING_JUMP
		45: MACRO_DATA_HOLDING_CROUCH
		46: MACRO_DATA_HOLDING_RELOAD
		47: MACRO_DATA_HOLDING_MELEE
		48: MACRO_PLAYING
		49: MACRO_PLAYING_FRAME
		50: SELECTOR_ENABLED
		51: SELECTOR_OPTION
		52: SELECTOR_FINISHED
		53: TURRET_SPOT_CHASE
		54: TURRET_SPOT_DUMMY_SLOT
		55: MACRO_DATA_TEAM
		70: hero_index
		71: hero_proj_data
		72: hero_ability_icon
		73: proj_g
		74: proj_vel
		75: proj_del
		76: proj_simtime
		77: proj_r
		78: proj_castdelay
		79: proj_chasedelay
		80: proj_fx
		81: proj_warning
		82: proj_p0
		83: proj_p1
		84: proj_p2
		85: proj_apex_t
		86: trajectory_hidden
		87: proj_dir
		88: using_ability
		89: player_hero
		90: ray_cast_t
		91: ray_cast_start
		92: ray_cast_end
		93: ray_cast_hit_pos
		94: proj_predict_land_pos
		95: proj_predict_land_t
		96: pos_mem
		97: poslock_bool
		98: poslock_posfac
		99: proj_p0_hidden
		100: proj_dir_hidden
		101: chasecam_bool
		102: chasecam_t
		103: chasecam_chasing
		104: predictcam_bool
		105: predictcam_dist
		106: eye_height
		107: trajlock_bool
		108: proj_override
		109: trajectory_hidden_manual
		111: chasecam_interrupt
		112: proj_dir_raw_hidden
		113: freecam_freeeye
		114: freecam_accel
		115: freecam_bool
		116: freecam_vel
		117: freecam_prevdir
		118: tumbleweed_highnoon_swag
}

subroutines
{
	0: HELP_PLAYERS
	8: STOP_MOMENTUM
	9: STOP_VERTICAL
	10: SELECTOR_TEAM_CREATE
	11: SELECTOR_TEAM_REMOVE
	13: DEPLOY_TURRET_CREATE
	14: DEPLOY_TURRET_REMOVE
	70: load_proj_data
	71: calc_proj
	72: swap_proj_data
	73: init_map_deathplane_y
	74: create_trajectory
	75: check_ability1
	76: hud_final
	77: save_trajectory_origin
	78: chasecam_start
	79: lockpos_only
	80: lockdir_only
	81: unlockpos_only
	82: unlockdir_only
}

disabled rule("TEST")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Create HUD Text(All Players(All Teams), Custom String("{0} {1}", Event Player.SELECTOR_ENABLED, Event Player.SELECTOR_OPTION),
			Null, Null, Left, 0, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
	}
}

rule("INIT GLOBAL")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.CODE_VERSION = Custom String("1.1");
		Global.CODE = Custom String("RHGDH - {0}", Global.CODE_VERSION);
		Global.MAP_ARRAY = Array(Array(Vector(225.810, 17, 249.500), Vector(51.880, 12, -100.750), Vector(-328.510, 13, 162.960), Vector(
			-0.390, -0.040, -0.920), Vector(0, 0, -1), Vector(0, 0, -1)), Array(Vector(340.770, -21, -44.240), Vector(28.120, 62,
			-147.050), Vector(-200.200, 2, -8.390), Vector(0.920, -0.040, -0.390), Vector(0, 0, -1), Vector(-0.710, -0.020, -0.710)),
			Array(Vector(0.120, 95, 134.050), Vector(1.080, 1, -18.130), Vector(-0.060, 271, 294.860), Vector(0, 0, 1), Vector(0, 0, -1),
			Vector(0, 0, -1)), Array(Vector(-174.830, -88.060, 0.040), Vector(-36.630, 14, -0.070), Vector(87.920, 129, 0), Vector(-1, 0,
			0), Vector(-1, 0, 0), Vector(-1, 0, 0)), Array(Vector(114.390, 6, -220.640), Vector(152.290, 3, 256.460), Vector(-180.290, 16,
			0), Vector(0.710, 0, -0.710), Vector(-0.710, 0, -0.710), Vector(-1, 0, 0)), Array(Vector(284.150, -12, -205.060), Vector(
			270.010, 43.690, 155.410), Vector(-92.760, -160.410, 59.640), Vector(-0.020, 0.010, -1), Vector(0, -0.300, 0.950), Vector(1,
			0.090, 0.020)));
		Global.MAP_CURRENT = 0;
		Set Slow Motion(Workshop Setting Integer(Custom String("0. GAME SETTINGS"), Custom String("SLOW MOTION"), 100, 1, 100, 0));
		Global.AUTO_CHANGE_PLAYERS = Array();
	}
}

rule("INIT PLAYER")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Disable Game Mode HUD(Event Player);
		Event Player.USING_FLY = False;
		Event Player.SELECTOR_ENABLED = False;
		Event Player.SELECTOR_OPTION = Team 1;
		Event Player.SELECTOR_FINISHED = False;
		Event Player.TURRET_SPOT_DUMMY_SLOT = Null;
		Event Player.MACRO_RECORDING = False;
		Call Subroutine(HELP_PLAYERS);
	}
}

rule("SUB HELP PLAYER")
{
	event
	{
		Subroutine;
		HELP_PLAYERS;
	}

	actions
	{
		If(!Is Dummy Bot(Event Player) && !Array Contains(Global.AUTO_CHANGE_PLAYERS, Event Player));
			"AUTO CHANGE TEAM"
			If(!Array Contains(Global.AUTO_CHANGE_PLAYERS, Event Player) && Team Of(Event Player) == Team 2 && Workshop Setting Toggle(
				Custom String("0. GAME SETTINGS"), Custom String("AUTO CHANGE TEAM"), True, 0));
				Move Player to Team(Event Player, Team 1, -1);
			End;
			Abort If(Team Of(Event Player) == Team 2);
			Modify Global Variable(AUTO_CHANGE_PLAYERS, Append To Array, Event Player);
			"ON GROUND"
			Create HUD Text(Event Player, Update Every Frame(Custom String("ON GROUND? => {0}", Update Every Frame(Is On Ground(
				Event Player)))), Null, Null, Top, 0, Update Every Frame(Update Every Frame(Is On Ground(Event Player)) ? Color(Green) : Color(
				Red)), Color(White), Color(White), String and Color, Default Visibility);
			"CODE"
			Create HUD Text(Event Player, Null, Null, Custom String("CODE: {0}", Global.CODE), Top, 1, Color(White), Color(White), Color(
				White), None, Default Visibility);
			"CHANGE HERO"
			Create HUD Text(Event Player, Null, Null, Custom String("CHANGE HERO => {0} + {1}", Button(Interact), Button(Melee)), Right, 2,
				Color(White), Color(White), Color(White), None, Visible Never);
			"FLY"
			Create HUD Text(Event Player, Null, Null, Custom String("TOGGLE FLY => {0} + {1}", Button(Crouch), Button(Ultimate)), Right, 3,
				Color(White), Color(White), Event Player.USING_FLY ? Color(Green) : Color(White), Color, Visible Never);
			"TP RAYCAST"
			Create HUD Text(Event Player, Null, Null, Custom String("TELEPORT => {0} + {1}", Button(Crouch), Button(Interact)), Right, 4,
				Color(White), Color(White), Color(White), None, Visible Never);
			"SPECTATE PLAYER"
			Create HUD Text(Event Player, Null, Null, Custom String("SPECTATE PLAYER => HOLD {0}", Button(Reload)), Right, 5, Color(White),
				Color(White), Event Player.SPECTATE_ENABLED ? Color(Green) : Color(White), Color, Visible Never);
			"SAVE TP POSITION"
			Create HUD Text(Event Player, Null, Null, Custom String("SAVE TP POSITION => DOUBLE {0}", Button(Crouch)), Right, 6, Color(White),
				Color(White), Color(White), None, Visible Never);
			"LOAD TP POSITION"
			Create HUD Text(Event Player, Null, Null, Custom String("LOAD TP POSITION => DOUBLE {0}", Button(Reload)), Right, 7, Color(White),
				Color(White), Color(White), None, Visible Never);
			If(Event Player == Host Player && Current Game Mode == Game Mode(Control));
				"CHANGE CONTROL MAP"
				Create HUD Text(Host Player, Null, Null, Custom String("CHANGE MAP => {0} + {1}", Button(Ability 2), Button(Ultimate)), Right, 8,
					Color(White), Color(White), Color(White), None, Visible Never);
			End;
			"SPAWN DUMMY BOT"
			Create HUD Text(Event Player, Null, Null, Custom String("SPAWN BOT => HOLD {0}", Button(Interact)), Right, 9, Color(White), Color(
				White), Color(White), None, Visible Never);
			"REMOVE DUMMY BOTS"
			Create HUD Text(Event Player, Null, Null, Custom String("REMOVE BOTS => {0} + {1}", Button(Reload), Button(Interact)), Right, 10,
				Color(White), Color(White), Color(White), None, Visible Never);
			"CREATE MACRO"
			Create HUD Text(Event Player, Null, Null, Custom String("CREATE MACRO => HOLD {0}", Button(Melee)), Right, 11, Color(White), Color(
				White), Event Player.MACRO_RECORDING == True || Event Player.MACRO_PLAYING == True ? Color(Green) : Color(White), Color,
				Visible Never);
			"REPLAY MACRO"
			Create HUD Text(Event Player, Null, Null, Custom String("REPLAY MACRO => {0} + {1}", Button(Ability 1), Button(Ultimate)), Right,
				12, Color(White), Color(White), Event Player.MACRO_PLAYING == True ? Color(Green) : Color(White), Color, Visible Never);
			"DEPLOY TURRET"
			Create HUD Text(Event Player, Null, Null, Custom String("DEPLOY TURRET => DOUBLE {0}", Button(Melee)), Right, 13, Color(White),
				Color(White), Event Player.TURRET_SPOT_DUMMY_SLOT != Null ? Color(Green) : Color(White), Color, Visible Never);
			"PROJECTILE PREDICTION"
			Create HUD Text(Event Player, Null, Null, Custom String("PROJECTILE PREDICTION => GROUP UP"), Right, 14, Color(White), Color(
				White), Event Player.trajectory_hidden_manual ? Color(White) : Color(Green), Color, Visible Never);
			"LANDING SPOT"
			Create HUD Text(Event Player.trajectory_hidden_manual ? Null : Event Player, Null, Null, Custom String("LANDING SPOT => {0}",
				Button(Melee)), Right, 15, Color(White), Color(White), Event Player.predictcam_bool ? Color(Green) : Color(White),
				Visible To and Color, Visible Never);
			"CHASE CAM"
			Create HUD Text(Event Player.trajectory_hidden_manual ? Null : Event Player, Null, Null, Custom String(
				"CHASE CAM => ULTIMATE STATUS"), Right, 16, Color(White), Color(White), Event Player.chasecam_bool ? Color(Green) : Color(
				White), Visible To and Color, Visible Never);
			"PAHARO"
			Create HUD Text(Event Player, Null, Custom String("                      Kephrii's Custom - Made by Paharo"), Null, Right, 100,
				Null, Color(Yellow), Color(White), None, Visible Never);
		End;
	}
}

rule("PLAYER NO COOLDOWN")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is True For Any(Array(Button(Ability 1), Button(Ability 2)), Is Button Held(Event Player, Current Array Element)) == True;
		disabled (Is Button Held(Event Player, Button(Ability 1)) == True || Is Button Held(Event Player, Button(Ability 2)) == True) == True;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
	}
}

rule("PLAYER RESET ULTIMATE")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Ultimate Charge Percent(Event Player) != 100;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
	}
}

rule("PLAYER CHANGE HERO")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Is Button Held(Event Player, Button(Interact)) && Is Button Held(Event Player, Button(Melee))) == True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Event Player.CHANGE_HERO_ARRAY = Array(Position Of(Event Player), Facing Direction Of(Event Player));
		Set Player Allowed Heroes(Event Player, Filtered Array(All Heroes, Current Array Element != Hero Of(Event Player)));
		Wait(0.100, Ignore Condition);
		Set Player Allowed Heroes(Event Player, All Heroes);
		Wait Until(Has Spawned(Event Player), 99999);
		disabled Wait(0.150, Ignore Condition);
		Teleport(Event Player, Event Player.CHANGE_HERO_ARRAY[0]);
		Set Facing(Event Player, Event Player.CHANGE_HERO_ARRAY[1], To World);
		If(Event Player.TURRET_SPOT_DUMMY_SLOT != Null);
			Call Subroutine(DEPLOY_TURRET_REMOVE);
			Wait(0.150, Ignore Condition);
			Call Subroutine(DEPLOY_TURRET_CREATE);
		End;
	}
}

rule("PLAYER FLY TOGGLE")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Is Button Held(Event Player, Button(Crouch)) && Is Button Held(Event Player, Button(Ultimate))) == True;
	}

	actions
	{
		Event Player.USING_FLY = !Event Player.USING_FLY;
	}
}

rule("PLAYER FLY > ON")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.USING_FLY == True;
	}

	actions
	{
		Set Gravity(Event Player, Absolute Value(0.001));
		Call Subroutine(STOP_MOMENTUM);
	}
}

rule("PLAYER FLY > OFF")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.USING_FLY == False;
	}

	actions
	{
		Stop Throttle In Direction(Event Player);
		Set Gravity(Event Player, 100);
		disabled Enable Messages(Event Player);
	}
}

rule("PLAYER FLY > SUB STOP_MOMENTUM")
{
	event
	{
		Subroutine;
		STOP_MOMENTUM;
	}

	actions
	{
		Apply Impulse(Event Player, Down, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Up, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Backward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Forward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Right, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Left, 0.001, To World, Cancel Contrary Motion);
	}
}

rule("PLAYER FLY > SUB STOP_VERTICAL")
{
	event
	{
		Subroutine;
		STOP_VERTICAL;
	}

	actions
	{
		Apply Impulse(Event Player, Down, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Up, 0.001, To World, Cancel Contrary Motion);
	}
}

rule("PLAYER FLY > HOLDING JUMP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Event Player.USING_FLY && Is Button Held(Event Player, Button(Jump))) == True;
	}

	actions
	{
		Apply Impulse(Event Player, Up, 1, To World, Incorporate Contrary Motion);
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
		Call Subroutine(STOP_VERTICAL);
	}
}

rule("PLAYER FLY > HOLDING CROUCH")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Event Player.USING_FLY && Is Button Held(Event Player, Button(Crouch))) == True;
	}

	actions
	{
		Apply Impulse(Event Player, Down, 1, To World, Incorporate Contrary Motion);
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
		Call Subroutine(STOP_VERTICAL);
	}
}

rule("PLAYER FLY > NOT HOLDING KEYS")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Event Player.USING_FLY && X Component Of(Throttle Of(Event Player)) == 0 && Z Component Of(Throttle Of(Event Player)) == 0)
			== True;
	}

	actions
	{
		Stop Accelerating(Event Player);
		Call Subroutine(STOP_MOMENTUM);
	}
}

rule("PLAYER FLY > HOLDING FORDWARD")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Workshop Setting Toggle(Custom String("2. FLY SETTINGS"), Custom String("ACCURATE MOVEMENT WHEN FLYING FORWARD"), False, 0)
			&& Event Player.USING_FLY && Z Component Of(Throttle Of(Event Player)) == 1) == True;
	}

	actions
	{
		Stop Accelerating(Event Player);
		Start Accelerating(Event Player, Update Every Frame(Direction Towards(Eye Position(Event Player), Facing Direction Of(Event Player)
			* 1000)), 6, 6, To World, Direction Rate and Max Speed);
	}
}

rule("PLAYER FLY > HOLDING BACKWARD")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Workshop Setting Toggle(Custom String("2. FLY SETTINGS"), Custom String("ACCURATE MOVEMENT WHEN FLYING BACKWARD"), False, 1)
			&& Event Player.USING_FLY && Z Component Of(Throttle Of(Event Player)) == -1) == True;
	}

	actions
	{
		Stop Accelerating(Event Player);
		Start Accelerating(Event Player, Update Every Frame(Direction Towards(Eye Position(Event Player), Facing Direction Of(Event Player)
			* -1000)), 6, 6, To World, Direction Rate and Max Speed);
	}
}

rule("PLAYER TP RAYCAST")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Is Button Held(Event Player, Button(Crouch)) && Is Button Held(Event Player, Button(Interact))) == True;
	}

	actions
	{
		Teleport(Event Player, Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(
			Event Player) * 100, All Players(All Teams), Event Player, True));
	}
}

rule("PLAYER SPECTATE")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Reload)) == True;
	}

	actions
	{
		If(Event Player.SPECTATE_ENABLED);
			Event Player.SPECTATE_ENABLED = !Event Player.SPECTATE_ENABLED;
			Set Invisible(Event Player.SPECTATE_PLAYER, None);
			Stop Camera(Event Player);
			Abort;
		End;
		Wait(0.333, Abort When False);
		Event Player.SPECTATE_ENABLED = !Event Player.SPECTATE_ENABLED;
		Event Player.SPECTATE_PLAYER = Player Closest To Reticle(Event Player, All Teams);
		Start Camera(Event Player, Update Every Frame(Eye Position(Event Player.SPECTATE_PLAYER)), Update Every Frame(
			Ray Cast Hit Position(Eye Position(Event Player.SPECTATE_PLAYER), Eye Position(Event Player.SPECTATE_PLAYER)
			+ Facing Direction Of(Event Player.SPECTATE_PLAYER) * 1000, Empty Array, All Players(All Teams), False)), 0);
		Set Invisible(Event Player.SPECTATE_PLAYER, All);
	}
}

rule("PLAYER TP POSITION > SAVE CHASE")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) == True;
	}

	actions
	{
		If(Event Player.SAVE_POS_CROUCH_CHASE > 0 && Event Player.SAVE_POS_CROUCH_CHASE < 1);
			Event Player.SAVE_POS_ARRAY = Array(Facing Direction Of(Event Player), Position Of(Event Player));
		Else;
			Chase Player Variable Over Time(Event Player, SAVE_POS_CROUCH_CHASE, 1, 0.250, Destination and Duration);
		End;
	}
}

rule("PLAYER TP POSITION > SAVE CHASE RESET")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.SAVE_POS_CROUCH_CHASE == 1;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, SAVE_POS_CROUCH_CHASE);
		Event Player.SAVE_POS_CROUCH_CHASE = 0;
	}
}

rule("PLAYER TP POSITION > LOAD POSITION")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Reload)) == True;
	}

	actions
	{
		If(Event Player.SAVE_POS_RELOAD_CHASE > 0 && Event Player.SAVE_POS_RELOAD_CHASE < 1);
			If(Event Player.SAVE_POS_ARRAY != Null);
				Set Facing(Event Player, Event Player.SAVE_POS_ARRAY[0], To World);
				Teleport(Event Player, Event Player.SAVE_POS_ARRAY[1]);
			End;
		Else;
			Chase Player Variable Over Time(Event Player, SAVE_POS_RELOAD_CHASE, 1, 0.250, Destination and Duration);
		End;
	}
}

rule("PLAYER TP POSITION > LOAD POSITION RESET")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.SAVE_POS_RELOAD_CHASE == 1;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, SAVE_POS_RELOAD_CHASE);
		Event Player.SAVE_POS_RELOAD_CHASE = 0;
	}
}

rule("MACRO > START RECORDING")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(!Is Dummy Bot(Event Player) && Is Button Held(Event Player, Button(Melee))
			&& !Event Player.MACRO_RECORDING && !Event Player.MACRO_PLAYING) == True;
	}

	actions
	{
		Wait(1, Abort When False);
		If(Event Player.TURRET_SPOT_DUMMY_SLOT != Null);
			Call Subroutine(DEPLOY_TURRET_REMOVE);
		End;
		Call Subroutine(SELECTOR_TEAM_CREATE);
		Wait Until(Event Player.SELECTOR_FINISHED, 99999);
		Event Player.MACRO_DATA_TEAM = Event Player.SELECTOR_OPTION;
		Event Player.SELECTOR_FINISHED = False;
		Event Player.MACRO_DATA_FACING = Empty Array;
		Event Player.MACRO_DATA_POSITION = Empty Array;
		Event Player.MACRO_DATA_HOLDING_ULT = Empty Array;
		Event Player.MACRO_DATA_HOLDING_AB1 = Empty Array;
		Event Player.MACRO_DATA_HOLDING_AB2 = Empty Array;
		Event Player.MACRO_DATA_HOLDING_PRIMARY = Empty Array;
		Event Player.MACRO_DATA_HOLDING_SECONDARY = Empty Array;
		Event Player.MACRO_DATA_HOLDING_JUMP = Empty Array;
		Event Player.MACRO_DATA_HOLDING_CROUCH = Empty Array;
		Event Player.MACRO_DATA_HOLDING_RELOAD = Empty Array;
		Event Player.MACRO_DATA_HOLDING_MELEE = Empty Array;
		Event Player.MACRO_PLAYER_ARRAY = Array(Position Of(Event Player), Facing Direction Of(Event Player), Hero Of(Event Player));
		Set Player Allowed Heroes(Event Player, Remove From Array(All Heroes, Hero Of(Event Player)));
		Wait(0.250, Ignore Condition);
		Reset Player Hero Availability(Event Player);
		Wait Until(Has Spawned(Event Player), 99999);
		Teleport(Event Player, Event Player.MACRO_PLAYER_ARRAY[0]);
		Set Facing(Event Player, Event Player.MACRO_PLAYER_ARRAY[1], To World);
		Wait(0.175, Ignore Condition);
		Set Status(Event Player, Null, Frozen, 1);
		Wait(1, Ignore Condition);
		Event Player.MACRO_DUMMY_SETTINGS = Array(Hero Of(Event Player), Team Of(Event Player));
		Create Progress Bar HUD Text(Event Player, Round To Integer(Event Player.MACRO_CHASE_VAR / 10 * 100, To Nearest), Custom String(
			""), Left, 0, Color(Red), Color(White), Values, Default Visibility);
		Chase Player Variable Over Time(Event Player, MACRO_CHASE_VAR, 10, 10, None);
		Event Player.MACRO_RECORDING = True;
		While(Event Player.MACRO_RECORDING);
			Modify Player Variable(Event Player, MACRO_DATA_FACING, Append To Array, Facing Direction Of(Event Player));
			Modify Player Variable(Event Player, MACRO_DATA_POSITION, Append To Array, Position Of(Event Player));
			Modify Player Variable(Event Player, MACRO_DATA_HOLDING_ULT, Append To Array, Is Button Held(Event Player, Button(Ultimate)));
			Modify Player Variable(Event Player, MACRO_DATA_HOLDING_AB1, Append To Array, Is Button Held(Event Player, Button(Ability 1)));
			Modify Player Variable(Event Player, MACRO_DATA_HOLDING_AB2, Append To Array, Is Button Held(Event Player, Button(Ability 2)));
			Modify Player Variable(Event Player, MACRO_DATA_HOLDING_PRIMARY, Append To Array, Is Button Held(Event Player, Button(
				Primary Fire)));
			Modify Player Variable(Event Player, MACRO_DATA_HOLDING_SECONDARY, Append To Array, Is Button Held(Event Player, Button(
				Secondary Fire)));
			Modify Player Variable(Event Player, MACRO_DATA_HOLDING_JUMP, Append To Array, Is Button Held(Event Player, Button(Jump)));
			Modify Player Variable(Event Player, MACRO_DATA_HOLDING_CROUCH, Append To Array, Is Button Held(Event Player, Button(Crouch)));
			Modify Player Variable(Event Player, MACRO_DATA_HOLDING_RELOAD, Append To Array, Is Button Held(Event Player, Button(Reload)));
			Modify Player Variable(Event Player, MACRO_DATA_HOLDING_MELEE, Append To Array, Is Button Held(Event Player, Button(Melee)));
			Wait(0.016, Ignore Condition);
		End;
	}
}

rule("MACRO > FINISH RECORDING")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.MACRO_CHASE_VAR == 10;
	}

	actions
	{
		Event Player.MACRO_RECORDING = False;
		Stop Chasing Player Variable(Event Player, MACRO_CHASE_VAR);
		Event Player.MACRO_CHASE_VAR = 0;
		Start Forcing Player To Be Hero(Event Player, Event Player.MACRO_PLAYER_ARRAY[2]);
		Stop Forcing Player To Be Hero(Event Player);
		Destroy Progress Bar HUD Text(Last Text ID);
		Event Player.MACRO_PLAYING = True;
	}
}

rule("MACRO > START PLAYING")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.MACRO_PLAYING == True;
	}

	actions
	{
		Create Dummy Bot(Event Player.MACRO_DUMMY_SETTINGS[0], Event Player.MACRO_DATA_TEAM, Number Of Players(
			Event Player.MACRO_DATA_TEAM), Event Player.MACRO_PLAYER_ARRAY[0], Event Player.MACRO_PLAYER_ARRAY[1]);
		Wait(2, Ignore Condition);
		While(Event Player.MACRO_PLAYING_FRAME != Count Of(Event Player.MACRO_DATA_POSITION));
			"POS"
			If(
				Event Player.MACRO_DATA_POSITION[Event Player.MACRO_PLAYING_FRAME] != Event Player.MACRO_DATA_POSITION[Event Player.MACRO_PLAYING_FRAME - 1] && Event Player.MACRO_PLAYING_FRAME != 0);
				Start Throttle In Direction(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM),
					Direction Towards(Position Of(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1,
					Event Player.MACRO_DATA_TEAM)), Event Player.MACRO_DATA_POSITION[Event Player.MACRO_PLAYING_FRAME]), 1, To World,
					Add to existing throttle, None);
			Else;
				Stop Throttle In Direction(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM));
			End;
			"FACING"
			Set Facing(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM),
				Event Player.MACRO_DATA_FACING[Event Player.MACRO_PLAYING_FRAME], To World);
			"ULT"
			If(Event Player.MACRO_DATA_HOLDING_ULT[Event Player.MACRO_PLAYING_FRAME] == True);
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
					Ultimate)) == False);
					Start Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Ultimate));
				End;
			Else;
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
					Ultimate)) == True);
					Stop Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Ultimate));
				End;
			End;
			"AB1"
			If(Event Player.MACRO_DATA_HOLDING_AB1[Event Player.MACRO_PLAYING_FRAME] == True);
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
					Ability 1)) == False);
					Start Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Ability 1));
				End;
			Else;
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
					Ability 1)) == True);
					Stop Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Ability 1));
				End;
			End;
			"AB2"
			If(Event Player.MACRO_DATA_HOLDING_AB2[Event Player.MACRO_PLAYING_FRAME] == True);
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
					Ability 2)) == False);
					Start Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Ability 2));
				End;
			Else;
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
					Ability 2)) == True);
					Stop Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Ability 2));
				End;
			End;
			"PRIMARY"
			If(Event Player.MACRO_DATA_HOLDING_PRIMARY[Event Player.MACRO_PLAYING_FRAME] == True);
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
					Primary Fire)) == False);
					Start Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Primary Fire));
				End;
			Else;
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
					Primary Fire)) == True);
					Stop Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Primary Fire));
				End;
			End;
			"SECONDARY"
			If(Event Player.MACRO_DATA_HOLDING_SECONDARY[Event Player.MACRO_PLAYING_FRAME] == True);
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
					Secondary Fire)) == False);
					Start Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Secondary Fire));
				End;
			Else;
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
					Secondary Fire)) == True);
					Stop Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Secondary Fire));
				End;
			End;
			"JUMP"
			If(Event Player.MACRO_DATA_HOLDING_JUMP[Event Player.MACRO_PLAYING_FRAME] == True);
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(Jump))
					== False);
					Start Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Jump));
				End;
			Else;
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(Jump))
					== True);
					Stop Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Jump));
				End;
			End;
			"CROUCH"
			If(Event Player.MACRO_DATA_HOLDING_CROUCH[Event Player.MACRO_PLAYING_FRAME] == True);
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
					Crouch)) == False);
					Start Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Crouch));
				End;
			Else;
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
					Crouch)) == True);
					Stop Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Crouch));
				End;
			End;
			"RELOAD"
			If(Event Player.MACRO_DATA_HOLDING_RELOAD[Event Player.MACRO_PLAYING_FRAME] == True);
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
					Reload)) == False);
					Start Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Reload));
				End;
			Else;
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
					Reload)) == True);
					Stop Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Reload));
				End;
			End;
			"MELEE"
			If(Event Player.MACRO_DATA_HOLDING_MELEE[Event Player.MACRO_PLAYING_FRAME] == True);
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
					Melee)) == False);
					Start Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Melee));
				End;
			Else;
				If(Is Button Held(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
					Melee)) == True);
					Stop Holding Button(Players In Slot(Number Of Players(Event Player.MACRO_DATA_TEAM) - 1, Event Player.MACRO_DATA_TEAM), Button(
						Melee));
				End;
			End;
			Event Player.MACRO_PLAYING_FRAME += 1;
			Wait(0.016, Ignore Condition);
		End;
		Destroy Dummy Bot(Event Player.MACRO_DATA_TEAM, Number Of Players(Event Player.MACRO_DATA_TEAM) - 1);
		Event Player.MACRO_PLAYING_FRAME = 0;
		Event Player.MACRO_PLAYING = False;
	}
}

rule("MACRO > REPLAY")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(
			Event Player.MACRO_DATA_POSITION != 0 && Event Player.MACRO_RECORDING != True && Event Player.MACRO_PLAYING != True && Is Button Held(
			Event Player, Button(Ultimate)) && Is Button Held(Event Player, Button(Ability 1))) == True;
	}

	actions
	{
		Event Player.MACRO_PLAYING = True;
	}
}

rule("CHANGE CONTROL MAP")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Event Player == Host Player && Current Game Mode == Game Mode(Control) && Is Button Held(Event Player, Button(Ultimate))
			&& Is Button Held(Event Player, Button(Ability 2))) == True;
	}

	actions
	{
		Global.MAP_CURRENT += 1;
		If(Global.MAP_CURRENT == 3);
			Global.MAP_CURRENT = 0;
		End;
		If(Current Map == Map(Busan));
			Teleport(All Players(All Teams), Global.MAP_ARRAY[0][Global.MAP_CURRENT]);
			Set Facing(All Players(All Teams), Global.MAP_ARRAY[0][Global.MAP_CURRENT + 3], To World);
		Else If(Current Map == Map(Ilios));
			Teleport(All Players(All Teams), Global.MAP_ARRAY[1][Global.MAP_CURRENT]);
			Set Facing(All Players(All Teams), Global.MAP_ARRAY[1][Global.MAP_CURRENT + 3], To World);
		Else If(Current Map == Map(Lijiang Tower) || Current Map == Map(Lijiang Tower Lunar New Year));
			Teleport(All Players(All Teams), Global.MAP_ARRAY[2][Global.MAP_CURRENT]);
			Set Facing(All Players(All Teams), Global.MAP_ARRAY[2][Global.MAP_CURRENT + 3], To World);
		Else If(Current Map == Map(Nepal));
			Teleport(All Players(All Teams), Global.MAP_ARRAY[3][Global.MAP_CURRENT]);
			Set Facing(All Players(All Teams), Global.MAP_ARRAY[3][Global.MAP_CURRENT + 3], To World);
		Else If(Current Map == Map(Oasis));
			Teleport(All Players(All Teams), Global.MAP_ARRAY[4][Global.MAP_CURRENT]);
			Set Facing(All Players(All Teams), Global.MAP_ARRAY[4][Global.MAP_CURRENT + 3], To World);
		Else If(Current Map == Map(Antarctic Peninsula));
			Teleport(All Players(All Teams), Global.MAP_ARRAY[5][Global.MAP_CURRENT]);
			Set Facing(All Players(All Teams), Global.MAP_ARRAY[5][Global.MAP_CURRENT + 3], To World);
		End;
	}
}

rule("AUTO RESURRECT")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		If(Workshop Setting Toggle(Custom String("0. GAME SETTINGS"), Custom String("AUTO RESURRECT NEAREST WALKABLE POSITION"), True, 1)
			== True);
			Teleport(Event Player, Nearest Walkable Position(Position Of(Event Player)));
			Wait(0.250, Ignore Condition);
			Resurrect(Event Player);
		End;
	}
}

rule("DUMMIES > SPAWN")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
	}

	actions
	{
		Wait(1, Abort When False);
		Call Subroutine(SELECTOR_TEAM_CREATE);
		Wait Until(Event Player.SELECTOR_FINISHED, 99999);
		Event Player.SELECTOR_FINISHED = False;
		Create Dummy Bot(Hero(Ana), Event Player.SELECTOR_OPTION, -1, Position Of(Event Player), Event Player);
	}
}

rule("DUMMIES > RESURRECT")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		(Workshop Setting Toggle(Custom String("1. DUMMY BOTS SETTINGS"), Custom String("AUTO RESURRECT DUMMY BOTS"), True, 0)
			&& Is Dummy Bot(Event Player)) == True;
		Event Player.TURRET_SPOT_DUMMY_SLOT == Null;
	}

	actions
	{
		Resurrect(Event Player);
	}
}

rule("DUMMIES > REMOVE")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Is Button Held(Event Player, Button(Reload)) && Is Button Held(Event Player, Button(Interact))) == True;
	}

	actions
	{
		Call Subroutine(DEPLOY_TURRET_REMOVE);
		Destroy All Dummy Bots;
	}
}

rule("SELECTOR > SUB CREATE")
{
	event
	{
		Subroutine;
		SELECTOR_TEAM_CREATE;
	}

	actions
	{
		Disable Messages(Event Player);
		Disable Hero HUD(Event Player);
		Disable Game Mode In-World UI(Event Player);
		Start Camera(Event Player, Vector(0, 200, 0), Vector(0, 210, 0), 0);
		Create In-World Text(Event Player, Custom String("SELECT A TEAM"), Vector(0, 210, 0), 3, Do Not Clip, None, Color(White),
			Default Visibility);
		Create In-World Text(Event Player, Custom String("TEAMMATE"), Vector(3, 210, 1), 3, Do Not Clip, Color,
			Event Player.SELECTOR_OPTION == Team Of(Event Player) ? Color(Green) : Color(Gray), Default Visibility);
		Create In-World Text(Event Player, Custom String("ENEMY"), Vector(-3, 210, 1), 3, Do Not Clip, Color,
			Event Player.SELECTOR_OPTION == Opposite Team Of(Team Of(Event Player)) ? Color(Green) : Color(Gray), Default Visibility);
		Create In-World Text(Event Player, Custom String("{0} TO CHANGE, {1} TO SELECT", Button(Primary Fire), Button(Crouch)), Vector(0,
			210, 2), 3, Do Not Clip, None, Color(White), Default Visibility);
		Event Player.SELECTOR_ENABLED = True;
		Set Status(Event Player, Null, Frozen, 9999);
	}
}

rule("SELECTOR > CHANGE OPTION")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.SELECTOR_ENABLED == True;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
	}

	actions
	{
		Event Player.SELECTOR_OPTION = Event Player.SELECTOR_OPTION == Team 1 ? Team 2 : Team 1;
	}
}

rule("SELECTOR > SELECT OPTION")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.SELECTOR_ENABLED == True;
		Is Button Held(Event Player, Button(Crouch)) == True;
	}

	actions
	{
		Call Subroutine(SELECTOR_TEAM_REMOVE);
	}
}

rule("SELECTOR > SUB REMOVE")
{
	event
	{
		Subroutine;
		SELECTOR_TEAM_REMOVE;
	}

	actions
	{
		Event Player.SELECTOR_ENABLED = False;
		Clear Status(Event Player, Frozen);
		Enable Messages(Event Player);
		Enable Hero HUD(Event Player);
		Enable Game Mode In-World UI(Event Player);
		Stop Camera(Event Player);
		Destroy All In-World Text;
		Event Player.SELECTOR_FINISHED = True;
	}
}

rule("DEPLOY TURRET")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Melee)) == True;
		Is Dummy Bot(Event Player) == False;
		Event Player.MACRO_RECORDING == False;
	}

	actions
	{
		If(Event Player.TURRET_SPOT_CHASE > 0 && Event Player.TURRET_SPOT_CHASE < 1);
			If(Event Player.TURRET_SPOT_DUMMY_SLOT == Null);
				Call Subroutine(DEPLOY_TURRET_CREATE);
			End;
			Press Button(Players In Slot(Event Player.TURRET_SPOT_DUMMY_SLOT, Team Of(Event Player)), Button(Ability 1));
		Else;
			Chase Player Variable Over Time(Event Player, TURRET_SPOT_CHASE, 1, 0.250, Destination and Duration);
		End;
	}
}

rule("DEPLOY TURRET > RESET CHASE")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.TURRET_SPOT_CHASE == 1;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, TURRET_SPOT_CHASE);
		Event Player.TURRET_SPOT_CHASE = 0;
	}
}

rule("DEPLOY TURRET > SUB CREATE")
{
	event
	{
		Subroutine;
		DEPLOY_TURRET_CREATE;
	}

	actions
	{
		Create Dummy Bot(Hero(Torbjörn), Team Of(Event Player), -1, Position Of(Event Player) + Vector(0, 2.500, 0), Down);
		Wait(0.250, Ignore Condition);
		Event Player.TURRET_SPOT_DUMMY_SLOT = Number Of Players(Team Of(Event Player)) - 1;
		Players In Slot(Event Player.TURRET_SPOT_DUMMY_SLOT, Team Of(Event Player)).TURRET_SPOT_DUMMY_SLOT = Event Player;
		Set Gravity(Players In Slot(Event Player.TURRET_SPOT_DUMMY_SLOT, Team Of(Event Player)), 0.001);
		Attach Players(Players In Slot(Event Player.TURRET_SPOT_DUMMY_SLOT, Team Of(Event Player)), Event Player, Vector(0, 3, -1.500));
		Start Facing(Players In Slot(Event Player.TURRET_SPOT_DUMMY_SLOT, Team Of(Event Player)), Direction Towards(Players In Slot(
			Event Player.TURRET_SPOT_DUMMY_SLOT, Team Of(Event Player)), Closest Player To(Players In Slot(
			Event Player.TURRET_SPOT_DUMMY_SLOT, Team Of(Event Player)), Team Of(Event Player)) + Vector(0, 1.800, 0)), 10000, To World,
			Direction and Turn Rate);
		Disable Movement Collision With Environment(Players In Slot(Event Player.TURRET_SPOT_DUMMY_SLOT, Team Of(Event Player)), True);
		Disable Movement Collision With Players(Players In Slot(Event Player.TURRET_SPOT_DUMMY_SLOT, Team Of(Event Player)));
	}
}

rule("DEPLOY TURRET > SUB REMOVE")
{
	event
	{
		Subroutine;
		DEPLOY_TURRET_REMOVE;
	}

	actions
	{
		Destroy Dummy Bot(Team Of(Event Player), Event Player.TURRET_SPOT_DUMMY_SLOT);
		Event Player.TURRET_SPOT_DUMMY_SLOT = Null;
	}
}

rule("init")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"sphere,shaft 1.053046257,ringout 1.052807897,ringin 1.062128122"
		Global._FX = Array(10155.377 / 10000, 10530.462 / 10000, 10528.079 / 10000, 10621.281 / 10000);
		Global.data = Array(Array(Hero(Ana), Hero(Junkrat), Hero(Baptiste), Hero(Orisa), Hero(Zarya), Hero(Sombra), Hero(Ashe), Hero(
			Tracer), Hero(Cassidy), Hero(Mei), Hero(Torbjörn), Hero(Hanzo), Hero(Sigma), Hero(Widowmaker)), Array(Array(Array(Null, Null,
			Null, Null, Array(-9.840, 30, 0, 7, 0, 0, 0.350, False)), 4, Array(4, 0, 0), False), Array(Array(Array(-12.350, 25, 0.075, 7,
			0, 0, 0.100, False), Null, Null, Array(-20.300, 25, 0.090, 7, 0, 0.136, 0.250, False), Array(-20.200, 10, 0.095, 7, 0, 0,
			0.250, False)), 0, Array(2, 3, 0), True), Array(Array(Null, Array(-20.100, 60, 0.007, 7, 0, 0, 0.100, False), Null, Null,
			Array(-20.100, 60, 0.007, 7, 0, 0, 0.100, False)), 1, Array(3, 0, 6.500), True), Array(Array(Null, Null, Null, Null, Array(
			-9.840, 25, 0, 7, 0, 0.128, 0.400, False)), 4, Array(0, 0, 0), True), Array(Array(Null, Array(-9.840, 25, 0.100, 7, 0, 0,
			0.500, False), Array(-9.840, 25, 0.100, 7, 0, 0, 0.500, False), Null, Null), 1, Array(2.500, 6, 0), False), Array(Array(Null,
			Null, Null, Null, Array(-20.200, 25, 0.090, 5, 0, 0.096, 0.200, False)), 4, Array(15, 0, 0), True), Array(Array(Null, Null,
			Null, Null, Array(-8.030, 25, 0.070, 7, 0, 0.140, 0.400, False)), 4, Array(5, 0, 0), True), Array(Array(Null, Null, Array(
			-30.800, 15, 0.190, 2, 0, 0.144, 0.150, False), Null, Null), 2, Array(5, 0, 0), False), Array(Array(Null, Null, Array(-10,
			4.200, 0.577, 4, 0, 0, 0.300, False), Null, Array(-9.840, 30, 0, 7 / 30, 0, 0, 0.100, False)), 4, Array(3, 0, 0), False),
			Array(Array(Null, Null, Array(-9.900, 20, 0.090, 7, 0, 0.484, 0.600, False), Null, Null), 2, Array(10, 0, 0), False), Array(
			Array(Array(-9.810, 70, 0.015, 15, 0, 0, 0.100, True), Null, Array(-30.050, 40, 0, 5, 0, 0, 0.100, True), Array(-20, 17, 0, 4,
			0, 0.048, 0.100, True), Null), 0, Array(2.500, 40, 0), True), Array(Array(Array(-9.815, 110, 0, 15, 0, 0, 0.032, True), Null,
			Null, Null, Array(-9.815, 110, 0, 15, 0, 0, 0.032, True)), 0, Array(0, 9, 0), False), Array(Array(Array(-5.954, 49.700, 0,
			3 / 7, 0, 0, 0.048, False), Null, Null, Null, Array(-18.350, 37.400, 0.100, 6, 0, 0.640, 0.256, False)), 4, Array(2.500, 3, 0),
			True), Array(Array(Null, Null, Null, Null, Array(-9.840, 20, 0, 7, 0, 0.192, 0.160, False)), 4, Array(3, 0, 0), True)));
		Call Subroutine(init_map_deathplane_y);
		Call Subroutine(hud_final);
		Call Subroutine(create_trajectory);
	}
}

rule("init_player")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.trajectory_hidden = False;
		Event Player.trajectory_hidden_manual = True;
	}
}

rule("player_calc_proj_loop")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.trajectory_hidden_manual == False;
		Event Player.chasecam_chasing != True;
		Event Player.trajlock_bool != True;
		Event Player.freecam_bool != True;
	}

	actions
	{
		Call Subroutine(save_trajectory_origin);
		Call Subroutine(calc_proj);
		Wait(0.064, Abort When False);
		Loop If Condition Is True;
	}
}

rule("player_changed_hero")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Hero Of(Event Player) != Event Player.player_hero;
	}

	actions
	{
		Event Player.player_hero = Hero Of(Event Player);
		Event Player.eye_height = Eye Position(Event Player) - Position Of(Event Player);
		Call Subroutine(load_proj_data);
		Event Player.hero_ability_icon = Custom String("{0}{1}{2}", Event Player.hero_proj_data[0] != Null ? Ability Icon String(Hero Of(
			Event Player), Button(Primary Fire)) : Custom String(""), Event Player.hero_proj_data[1] != Null ? Ability Icon String(Hero Of(
			Event Player), Button(Secondary Fire)) : Custom String(""), Custom String("{0}{1}{2}",
			Event Player.hero_proj_data[2] != Null ? Ability Icon String(Hero Of(Event Player), Button(Ultimate)) : Custom String(""),
			Event Player.hero_proj_data[3] != Null ? Ability Icon String(Hero Of(Event Player), Button(Ability 1)) : Custom String(""),
			Event Player.hero_proj_data[4] != Null ? Ability Icon String(Hero Of(Event Player), Button(Ability 2)) : Custom String("")));
		Set Ultimate Charge(Event Player, 100);
		If(Event Player.pos_mem != 0);
			Teleport(Event Player, Event Player.pos_mem[0]);
			Set Facing(Event Player, Event Player.pos_mem[1], To World);
		End;
		Event Player.predictcam_dist = 0.800;
		Event Player.predictcam_bool = False;
		Event Player.trajectory_hidden = False;
		Event Player.tumbleweed_highnoon_swag = False;
		If(Event Player.chasecam_chasing == True);
			Start Rule(chasecam_start, Restart Rule);
		End;
	}
}

rule("player_action_predictcam (melee)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Melee)) == True;
		Event Player.freecam_bool != True;
		Event Player.trajectory_hidden_manual == False;
	}

	actions
	{
		If(Event Player.chasecam_chasing == False);
			Event Player.predictcam_bool = !Event Player.predictcam_bool;
		Else;
			Event Player.chasecam_interrupt = True;
			Start Rule(chasecam_start, Restart Rule);
		End;
	}
}

rule("predictcam_toggle_on")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.predictcam_bool == True;
	}

	actions
	{
		"final cam"
		Start Camera(Event Player, (1 - Event Player.proj_predict_land_t * Event Player.predictcam_dist) ^ 2 * Event Player.proj_p0 + 2 * (
			1 - Event Player.proj_predict_land_t * Event Player.predictcam_dist)
			* Event Player.proj_predict_land_t * Event Player.predictcam_dist * Event Player.proj_p1 + (
			Event Player.proj_predict_land_t * Event Player.predictcam_dist) ^ 2 * Event Player.proj_p2,
			Event Player.proj_predict_land_pos, 10);
	}
}

rule("predictcam_toggle_off")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.predictcam_bool == False;
	}

	actions
	{
		Stop Camera(Event Player);
	}
}

rule("player_action_chasecam (ult status)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Ultimate Status) == True;
		Event Player.trajectory_hidden_manual == False;
	}

	actions
	{
		Event Player.chasecam_bool = !Event Player.chasecam_bool;
	}
}

rule("player_action_trajhide (group up)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Group Up) == True;
	}

	actions
	{
		Event Player.chasecam_bool = False;
		Event Player.predictcam_bool = False;
		Event Player.trajectory_hidden_manual = !Event Player.trajectory_hidden_manual;
	}
}

rule("lockpos_only_toggle_on")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		((!Event Player.poslock_bool && Event Player.freecam_bool) || (Event Player.poslock_bool && !Event Player.freecam_bool)) == True;
	}

	actions
	{
		Call Subroutine(lockpos_only);
	}
}

rule("lockpos_only_toggle_off")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		!((!Event Player.poslock_bool && Event Player.freecam_bool) || (Event Player.poslock_bool && !Event Player.freecam_bool)) == True;
	}

	actions
	{
		Call Subroutine(unlockpos_only);
	}
}

rule("lockdir_only_toggle_on")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Event Player.poslock_bool && !Event Player.freecam_bool) == True;
	}

	actions
	{
		Call Subroutine(lockdir_only);
	}
}

rule("lockdir_only_toggle_off")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		!(Event Player.poslock_bool && !Event Player.freecam_bool) == True;
	}

	actions
	{
		Call Subroutine(unlockdir_only);
	}
}

rule("[sub] lockpos_only")
{
	event
	{
		Subroutine;
		lockpos_only;
	}

	actions
	{
		Disable Movement Collision With Environment(Event Player, True);
		Event Player.poslock_posfac[0] = Eye Position(Event Player) - Event Player.eye_height;
		Start Forcing Player Position(Event Player, Event Player.poslock_posfac[0], False);
	}
}

rule("[sub] unlockpos_only")
{
	event
	{
		Subroutine;
		unlockpos_only;
	}

	actions
	{
		Enable Movement Collision With Environment(Event Player);
		Stop Forcing Player Position(Event Player);
	}
}

rule("[sub] lockdir_only")
{
	event
	{
		Subroutine;
		lockdir_only;
	}

	actions
	{
		Event Player.poslock_posfac[1] = Facing Direction Of(Event Player);
		Start Facing(Event Player, Event Player.poslock_posfac[1], 10000, To World, None);
	}
}

rule("[sub] unlockdir_only")
{
	event
	{
		Subroutine;
		unlockdir_only;
	}

	actions
	{
		If(Event Player.freecam_bool);
			Stop Facing(Event Player);
			Set Facing(Event Player, Event Player.poslock_posfac[1], To World);
		Else;
			Stop Facing(Event Player);
		End;
	}
}

rule("check_using_primary")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.proj_override == False;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		Event Player.using_ability = 0;
		If(Event Player.hero_proj_data[Event Player.using_ability] != Null);
			Call Subroutine(swap_proj_data);
			If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
				Start Rule(chasecam_start, Restart Rule);
			End;
		End;
	}
}

rule("check_using_secondary")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.proj_override == False;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		Event Player.using_ability = 1;
		If(Event Player.hero_proj_data[Event Player.using_ability] != Null);
			Call Subroutine(swap_proj_data);
			If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
				Start Rule(chasecam_start, Restart Rule);
			End;
		End;
	}
}

rule("check_using_ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.proj_override == False;
		Is Button Held(Event Player, Button(Ultimate)) == True;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		Event Player.using_ability = 2;
		If(Event Player.hero_proj_data[Event Player.using_ability] != Null);
			Call Subroutine(swap_proj_data);
			If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
				Start Rule(chasecam_start, Restart Rule);
			End;
		End;
	}
}

rule("check_using_ability_1")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.proj_override == False;
		Is Button Held(Event Player, Button(Ability 1)) == True;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		Event Player.using_ability = 3;
		If(Event Player.hero_proj_data[Event Player.using_ability] != Null);
			Call Subroutine(swap_proj_data);
			If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
				Start Rule(chasecam_start, Restart Rule);
			End;
		End;
	}
}

rule("check_using_ability_2")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.proj_override == False;
		Is Button Held(Event Player, Button(Ability 2)) == True;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		Event Player.using_ability = 4;
		If(Event Player.hero_proj_data[Event Player.using_ability] != Null);
			Call Subroutine(swap_proj_data);
			If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
				Start Rule(chasecam_start, Restart Rule);
			End;
		End;
	}
}

rule("Hanzo: Primary Fire Charge")
{
	event
	{
		Ongoing - Each Player;
		All;
		Hanzo;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Is Using Ability 2(Event Player) != True;
	}

	actions
	{
		Event Player.proj_vel = 25;
		Chase Player Variable At Rate(Event Player, proj_vel, 110, 120, None);
		Wait Until(Is Button Held(Event Player, Button(Primary Fire)) == False, 99999);
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		Stop Chasing Player Variable(Event Player, proj_vel);
		If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
			Start Rule(chasecam_start, Restart Rule);
		End;
	}
}

rule("Hanzo: Using Storm Arrow")
{
	event
	{
		Ongoing - Each Player;
		All;
		Hanzo;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		If(Event Player.chasecam_chasing != True);
			Event Player.proj_vel = 110;
		End;
	}
}

rule("Hanzo: Fire Storm Arrow")
{
	event
	{
		Ongoing - Each Player;
		All;
		Hanzo;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Event Player.chasecam_bool == True;
		Event Player.chasecam_chasing == False;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
			Start Rule(chasecam_start, Restart Rule);
		End;
	}
}

rule("Torbjorn: Using Ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		Torbjörn;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		If(Event Player.chasecam_chasing != True);
			Event Player.using_ability = 2;
			Call Subroutine(swap_proj_data);
		End;
	}
}

rule("Torbjorn: Rivet")
{
	event
	{
		Ongoing - Each Player;
		All;
		Torbjörn;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Is Using Ultimate(Event Player) != True;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		If(Event Player.chasecam_chasing != True);
			Event Player.using_ability = 0;
			Call Subroutine(swap_proj_data);
		End;
		If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
			Start Rule(chasecam_start, Restart Rule);
		End;
	}
}

rule("Torbjorn: Firing Goo")
{
	event
	{
		Ongoing - Each Player;
		All;
		Torbjörn;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
			Start Rule(chasecam_start, Restart Rule);
		End;
	}
}

rule("Torbjorn: Deploy Turret")
{
	event
	{
		Ongoing - Each Player;
		All;
		Torbjörn;
	}

	conditions
	{
		Is Using Ultimate(Event Player) != True;
		Is Button Held(Event Player, Button(Ability 1)) == True;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		If(Event Player.chasecam_chasing != True);
			Event Player.using_ability = 3;
			Call Subroutine(swap_proj_data);
		End;
		If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
			Start Rule(chasecam_start, Restart Rule);
		End;
	}
}

rule("[sub] chasecam_start")
{
	event
	{
		Subroutine;
		chasecam_start;
	}

	actions
	{
		If(!(Event Player.chasecam_chasing || Event Player.chasecam_interrupt));
			Stop Chasing Player Variable(Event Player, chasecam_t);
			Event Player.chasecam_t = 0;
			"then wait for the cast time if any"
			If(Event Player.proj_castdelay > 0);
				Wait(Event Player.proj_castdelay, Ignore Condition);
				Call Subroutine(save_trajectory_origin);
			End;
			"do calc"
			Start Rule(calc_proj, Restart Rule);
			"start chasing immediately after casting"
			Chase Player Variable At Rate(Event Player, chasecam_t, Event Player.proj_predict_land_t, 1 / Event Player.proj_simtime,
				Destination and Rate);
			If(Event Player.chasecam_bool && !Event Player.freecam_bool);
				Event Player.predictcam_bool = False;
				Event Player.chasecam_chasing = True;
				Event Player.trajectory_hidden = True;
				Set Invisible(Event Player, All);
				"ensures projectile correction"
				Wait(0.016, Ignore Condition);
				"start camera"
				Start Camera(Event Player, Min(1 - Event Player.chasecam_t + Event Player.proj_chasedelay / Event Player.proj_simtime, 1)
					^ 2 * Event Player.proj_p0 + 2 * Min(1 - Event Player.chasecam_t + Event Player.proj_chasedelay / Event Player.proj_simtime, 1)
					* Max(Event Player.chasecam_t - Event Player.proj_chasedelay / Event Player.proj_simtime, 0) * Event Player.proj_p1 + Max(
					Event Player.chasecam_t - Event Player.proj_chasedelay / Event Player.proj_simtime, 0) ^ 2 * Event Player.proj_p2 - (
					Event Player.proj_dir == Up || Event Player.proj_dir == Down) * 0.008 * Direction From Angles(Horizontal Angle From Direction(
					Event Player.proj_dir_raw_hidden), 0), (1 - Event Player.chasecam_t) ^ 2 * Event Player.proj_p0 + 2 * (
					1 - Event Player.chasecam_t)
					* Event Player.chasecam_t * Event Player.proj_p1 + Event Player.chasecam_t ^ 2 * Event Player.proj_p2, 0);
			End;
			"wait for proj to hit"
			Wait(Event Player.proj_predict_land_t * Event Player.proj_simtime + Event Player.proj_chasedelay + 1.500 - 0.016,
				Abort When False);
		End;
		If(Event Player.chasecam_chasing);
			Stop Camera(Event Player);
		End;
		Set Invisible(Event Player, None);
		Event Player.trajectory_hidden = False;
		Event Player.chasecam_interrupt = False;
		Stop Chasing Player Variable(Event Player, chasecam_t);
		Event Player.chasecam_t = 0;
		Event Player.chasecam_chasing = False;
	}
}

rule("[sub] swap_projectile_data")
{
	event
	{
		Subroutine;
		swap_proj_data;
	}

	actions
	{
		Event Player.proj_g = Event Player.hero_proj_data[Event Player.using_ability][0];
		Event Player.proj_vel = Event Player.hero_proj_data[Event Player.using_ability][1];
		Event Player.proj_del = Event Player.hero_proj_data[Event Player.using_ability][2];
		Event Player.proj_simtime = Event Player.hero_proj_data[Event Player.using_ability][3];
		Event Player.proj_r = Event Player.hero_proj_data[Event Player.using_ability][4];
		Event Player.proj_castdelay = Event Player.hero_proj_data[Event Player.using_ability][5];
		Event Player.proj_chasedelay = Event Player.hero_proj_data[Event Player.using_ability][6];
		Event Player.proj_override = Event Player.hero_proj_data[Event Player.using_ability][7];
	}
}

rule("[sub] obsolete")
{
	event
	{
		Subroutine;
		check_ability1;
	}

	actions
	{
		If(Event Player.hero_proj_data[2] != Null);
			While(True);
				Wait Until(!Is Using Ability 1(Event Player), 99999);
				Wait Until(Is Using Ability 1(Event Player), 99999);
				Small Message(All Players(All Teams), Custom String("This ability is open for chase"));
			End;
		End;
	}
}

rule("[sub] map_deathplane")
{
	event
	{
		Subroutine;
		init_map_deathplane_y;
	}

	actions
	{
		If(Current Map == Map(Blizzard World));
			Global.map_deathplane_y = -6.490;
		Else If(Current Map == Map(Blizzard World Winter));
			Global.map_deathplane_y = -6.490;
		Else If(Current Map == Map(Dorado));
			Global.map_deathplane_y = -9.510;
		Else If(Current Map == Map(Eichenwalde));
			Global.map_deathplane_y = -7.720;
		Else If(Current Map == Map(Eichenwalde Halloween));
			Global.map_deathplane_y = -7.710;
		Else If(Current Map == Map(Hanamura));
			Global.map_deathplane_y = -8.510;
		Else If(Current Map == Map(Hanamura Winter));
			Global.map_deathplane_y = -8.500;
		Else If(Current Map == Map(Havana));
			Global.map_deathplane_y = -8.500;
		Else If(Current Map == Map(Hollywood));
			Global.map_deathplane_y = -30.510;
		Else If(Current Map == Map(Hollywood Halloween));
			Global.map_deathplane_y = -30.500;
		Else If(Current Map == Map(Horizon Lunar Colony));
			Global.map_deathplane_y = 0.410;
		Else If(Current Map == Map(Junkertown));
			Global.map_deathplane_y = -5.500;
		Else If(Current Map == Map(King's Row));
			Global.map_deathplane_y = -18.500;
		Else If(Current Map == Map(King's Row Winter));
			Global.map_deathplane_y = -18.500;
		Else If(Current Map == Map(Numbani));
			Global.map_deathplane_y = -10.500;
		Else If(Current Map == Map(Paris));
			Global.map_deathplane_y = 6.150;
		Else If(Current Map == Map(Rialto));
			Global.map_deathplane_y = -15.500;
		Else If(Current Map == Map(Route 66));
			Global.map_deathplane_y = -15.500;
		Else If(Current Map == Map(Temple of Anubis));
			Global.map_deathplane_y = -10.500;
		Else If(Current Map == Map(Volskaya Industries));
			Global.map_deathplane_y = -12.500;
		Else If(Current Map == Map(Watchpoint: Gibraltar));
			Global.map_deathplane_y = -18.500;
		Else If(Current Map == Map(Busan));
			If(Objective Index == 0);
				Global.map_deathplane_y = 0.410;
			Else If(Objective Index == 1);
				Global.map_deathplane_y = 2.020;
			Else If(Objective Index == 2);
				Global.map_deathplane_y = -8.500;
			End;
		Else If(Current Map == Map(Ilios));
			If(Objective Index == 0);
				Global.map_deathplane_y = -37.450;
			Else If(Objective Index == 1);
				Global.map_deathplane_y = -10.190;
			Else If(Objective Index == 2);
				Global.map_deathplane_y = 49.360;
			End;
		Else If(Current Map == Map(Nepal));
			If(Objective Index == 0);
				Global.map_deathplane_y = -106.180;
			Else If(Objective Index == 1);
				Global.map_deathplane_y = 0.840;
			Else If(Objective Index == 2);
				Global.map_deathplane_y = 115.150;
			End;
		Else If(Current Map == Map(Oasis));
			If(Objective Index == 0);
				Global.map_deathplane_y = -8.990;
			Else If(Objective Index == 1);
				Global.map_deathplane_y = -0.510;
			Else If(Objective Index == 2);
				Global.map_deathplane_y = 2.080;
			End;
		Else If(Current Map == Map(Lijiang Tower));
			If(Objective Index == 0);
				Global.map_deathplane_y = -12.510;
			Else If(Objective Index == 1);
				Global.map_deathplane_y = 82.570;
			Else If(Objective Index == 2);
				Global.map_deathplane_y = 250.200;
			End;
		Else If(Current Map == Map(Lijiang Tower Lunar New Year));
			If(Objective Index == 0);
				Global.map_deathplane_y = -12.510;
			Else If(Objective Index == 1);
				Global.map_deathplane_y = 82.570;
			Else If(Objective Index == 2);
				Global.map_deathplane_y = 250.200;
			End;
		Else If(Current Map == Map(Workshop Chamber));
			Global.map_deathplane_y = -25.500;
		Else If(Current Map == Map(Workshop Expanse));
			Global.map_deathplane_y = -27;
		Else If(Current Map == Map(Workshop Expanse Night));
			Global.map_deathplane_y = -27;
		Else If(Current Map == Map(Workshop Green Screen));
			Global.map_deathplane_y = -27;
		Else If(Current Map == Map(Workshop Island));
			Global.map_deathplane_y = -27;
		Else If(Current Map == Map(Workshop Island Night));
			Global.map_deathplane_y = -27;
		End;
	}
}

rule("[sub] create trajectory")
{
	event
	{
		Subroutine;
		create_trajectory;
	}

	actions
	{
		For Global Variable(loop_i, 0, 1, 0.020);
			Wait(0.016, Ignore Condition);
		End;
		"hit position marker"
		Create Effect(Local Player.trajectory_hidden_manual ? Null : Local Player, Sphere, Color(Red), Local Player.proj_predict_land_pos,
			0.200 * Evaluate Once(Global._FX[0]), Visible To Position and Radius);
		"apex"
		Create Effect(Local Player.trajectory_hidden_manual ? Null : Local Player, Sphere, Color(Green), (1 - Local Player.proj_apex_t)
			^ 2 * Local Player.proj_p0 + 2 * (1 - Local Player.proj_apex_t)
			* Local Player.proj_apex_t * Local Player.proj_p1 + Local Player.proj_apex_t ^ 2 * Local Player.proj_p2, 0.200 * Evaluate Once(
			Global._FX[0]), Visible To Position and Radius);
		"primary range"
		Create Effect(Local Player.trajectory_hidden_manual ? Null : Local Player, Sphere, Color(Sky Blue),
			Local Player.proj_predict_land_pos, Local Player.proj_fx[0] * Evaluate Once(Global._FX[0]), Visible To Position and Radius);
		"secondary range"
		Create Effect(Local Player.trajectory_hidden_manual ? Null : Local Player, Sphere, Color(Blue), Local Player.proj_predict_land_pos,
			Local Player.proj_fx[1] * Evaluate Once(Global._FX[0]), Visible To Position and Radius);
		"cylinder range"
		Create Effect(Local Player.trajectory_hidden_manual ? Null : Local Player, Light Shaft, Color(Blue),
			Local Player.proj_predict_land_pos, Local Player.proj_fx[2] * Evaluate Once(Global._FX[1]), Visible To Position and Radius);
		"cylinder range (ring)"
		Create Effect(Local Player.trajectory_hidden_manual ? Null : Local Player, Ring, Color(Blue), Local Player.proj_predict_land_pos,
			Local Player.proj_fx[2] * Evaluate Once(Global._FX[2]), Visible To Position and Radius);
	}
}

rule("[sub] load_proj_data")
{
	event
	{
		Subroutine;
		load_proj_data;
	}

	actions
	{
		Event Player.hero_index = Index Of Array Value(Global.data[0], Hero Of(Event Player));
		Event Player.hero_proj_data = Global.data[1][Event Player.hero_index][0];
		Event Player.proj_fx = Global.data[1][Event Player.hero_index][2];
		Event Player.proj_warning = Global.data[1][Event Player.hero_index][3];
		Event Player.using_ability = Global.data[1][Event Player.hero_index][1];
		Call Subroutine(swap_proj_data);
	}
}

rule("[sub] save_eye_and_fac")
{
	event
	{
		Subroutine;
		save_trajectory_origin;
	}

	actions
	{
		If(Event Player.tumbleweed_highnoon_swag);
			Event Player.proj_p0_hidden = World Vector Of(Vector(6.595, 0.430, 3), Event Player, Rotation And Translation);
			Event Player.proj_dir_raw_hidden = Facing Direction Of(Event Player);
			Event Player.proj_dir_hidden = Normalize(World Vector Of(Right, Event Player, Rotation) + Event Player.proj_del * Up);
		Else;
			Event Player.proj_p0_hidden = Eye Position(Event Player);
			Event Player.proj_dir_raw_hidden = Facing Direction Of(Event Player);
			Event Player.proj_dir_hidden = Vertical Facing Angle Of(Event Player) < -89 ? Up : (Vertical Facing Angle Of(Event Player)
				> 89 ? Down : Normalize(Facing Direction Of(Event Player) + Event Player.proj_del * Up));
		End;
	}
}

rule("[sub] calculate_projectile_parameters")
{
	event
	{
		Subroutine;
		calc_proj;
	}

	actions
	{
		Event Player.proj_p0 = Event Player.proj_p0_hidden;
		Event Player.proj_dir = Event Player.proj_dir_hidden;
		Event Player.proj_p1 = Event Player.proj_p0 + 0.500 * Event Player.proj_vel * Event Player.proj_simtime * Event Player.proj_dir;
		Event Player.proj_p2 = Event Player.proj_p0 + Event Player.proj_vel * Event Player.proj_simtime * Event Player.proj_dir + 0.500 * Event Player.proj_simtime * Event Player.proj_simtime * Event Player.proj_g * Up;
		Event Player.proj_apex_t = -1 * Y Component Of(Event Player.proj_dir)
			* Event Player.proj_vel / Event Player.proj_g / Event Player.proj_simtime;
		If(Event Player.proj_r == 0);
			For Player Variable(Event Player, ray_cast_t, 0, 1, 0.002);
				Event Player.ray_cast_start = Evaluate Once((1 - Event Player.ray_cast_t) * (1 - Event Player.ray_cast_t))
					* Event Player.proj_p0 + Evaluate Once(2 * (1 - Event Player.ray_cast_t) * Event Player.ray_cast_t)
					* Event Player.proj_p1 + Evaluate Once(Event Player.ray_cast_t * Event Player.ray_cast_t) * Event Player.proj_p2;
				If(Y Component Of(Event Player.ray_cast_start) < Global.map_deathplane_y);
					Break;
				End;
				Event Player.ray_cast_end = Evaluate Once((0.998 - Event Player.ray_cast_t) * (0.998 - Event Player.ray_cast_t))
					* Event Player.proj_p0 + Evaluate Once(2 * (0.998 - Event Player.ray_cast_t) * (Event Player.ray_cast_t + 0.002))
					* Event Player.proj_p1 + Evaluate Once((Event Player.ray_cast_t + 0.002) * (Event Player.ray_cast_t + 0.002))
					* Event Player.proj_p2;
				Event Player.ray_cast_hit_pos = Ray Cast Hit Position(Event Player.ray_cast_start, Event Player.ray_cast_end, Null, Event Player,
					True);
				"hit something"
				If(Event Player.ray_cast_hit_pos != Event Player.ray_cast_end);
					Break;
				End;
			End;
			"adjustment term"
			Event Player.proj_predict_land_t = Event Player.ray_cast_t + 0.002 * (Distance Between(Event Player.ray_cast_start,
				Event Player.ray_cast_hit_pos) / Distance Between(Event Player.ray_cast_start, Event Player.ray_cast_end));
			Event Player.proj_predict_land_pos = Event Player.ray_cast_hit_pos;
			Wait(0.064, Ignore Condition);
		Else;
			Wait(0.016, Ignore Condition);
		End;
	}
}

rule("freecam_toggle")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Thanks) == True;
	}

	actions
	{
		Event Player.freecam_bool = !Event Player.freecam_bool;
	}
}

rule("freecam_movement_loop")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.freecam_bool == True;
	}

	actions
	{
		If(Event Player.poslock_bool);
			Event Player.freecam_accel = 0 * Up;
		Else;
			"get controls"
			Event Player.freecam_accel = Throttle Of(Event Player) + Up * Is Button Held(Event Player, Button(Jump)) + Down * Is Button Held(
				Event Player, Button(Crouch));
		End;
		"normalize if non-zero vector"
		If(Event Player.freecam_accel != 0 * Up);
			Event Player.freecam_accel = Normalize(Event Player.freecam_accel);
			"transform the accel to local space"
			Event Player.freecam_accel = X Component Of(Event Player.freecam_accel) * World Vector Of(Left, Event Player, Rotation)
				+ Y Component Of(Event Player.freecam_accel) * Direction From Angles(Horizontal Facing Angle Of(Event Player),
				Vertical Facing Angle Of(Event Player) - 90) + Z Component Of(Event Player.freecam_accel) * Facing Direction Of(Event Player);
			"add accel to vel"
			Event Player.freecam_vel += 0.090 * Event Player.freecam_accel;
			"if norm(vel) > 1"
			If(Distance Between(0 * Up, Event Player.freecam_vel) > 1);
				Event Player.freecam_vel = Normalize(Event Player.freecam_vel);
			End;
		"no accel, decel"
		Else;
			If(Distance Between(0 * Up, Event Player.freecam_vel) < 0.080);
				Event Player.freecam_vel = 0 * Up;
			Else;
				Event Player.freecam_vel -= 0.060 * Event Player.freecam_vel;
			End;
		End;
		Event Player.freecam_freeeye += 0.250 * Event Player.freecam_vel;
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("freecam locked")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.freecam_bool == True;
		Event Player.poslock_bool == True;
	}

	actions
	{
		Event Player.freecam_prevdir = Facing Direction Of(Event Player);
		Set Facing(Event Player, Event Player.proj_dir_raw_hidden, To World);
	}
}

rule("freecam unlock")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.freecam_bool == True;
		Event Player.poslock_bool != True;
	}

	actions
	{
		Set Facing(Event Player, Event Player.freecam_prevdir, To World);
	}
}

rule("freecam on")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.freecam_bool == True;
	}

	actions
	{
		Event Player.freecam_bool = True;
		Event Player.freecam_prevdir = Facing Direction Of(Event Player);
		Set Facing(Event Player, Event Player.proj_dir_raw_hidden, To World);
		Event Player.freecam_freeeye = Eye Position(Event Player);
		Start Camera(Event Player, Update Every Frame(Event Player.freecam_freeeye), Update Every Frame(
			Event Player.freecam_freeeye + 50 * (Event Player.poslock_bool ? Event Player.freecam_prevdir : Facing Direction Of(
			Event Player))), 1000);
	}
}

rule("freecam off")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.freecam_bool == False;
	}

	actions
	{
		Event Player.freecam_bool = False;
		Stop Camera(Event Player);
	}
}
